$date
	Mon Mar  8 20:59:30 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module instruction_fetch_tb $end
$var wire 1 ! mode_mem $end
$var wire 1 " rd $end
$var wire 1 # wn $end
$var wire 16 $ write_data1 [15:0] $end
$var wire 16 % write_data2 [15:0] $end
$var wire 16 & write_data_mem [15:0] $end
$var wire 1 ' wr_mem $end
$var wire 1 ( wn_reg2 $end
$var wire 1 ) wn_reg1 $end
$var wire 4 * wb_reg [3:0] $end
$var wire 4 + reg_id2 [3:0] $end
$var wire 4 , reg_id1 [3:0] $end
$var wire 16 - reg_data2 [15:0] $end
$var wire 16 . reg_data1 [15:0] $end
$var wire 1 / rd_reg2 $end
$var wire 1 0 rd_reg1 $end
$var wire 1 1 rd_mem $end
$var wire 6 2 opcode [5:0] $end
$var wire 16 3 op2 [15:0] $end
$var wire 16 4 op1 [15:0] $end
$var wire 2 5 mode [1:0] $end
$var wire 16 6 mem_data [15:0] $end
$var wire 16 7 address [15:0] $end
$var reg 1 8 clk $end
$var reg 24 9 instruction [23:0] $end
$var reg 1 : reset $end
$scope module data_memory $end
$var wire 1 8 clk $end
$var wire 1 ! mode $end
$var wire 16 ; write_data [15:0] $end
$var wire 1 ' wn $end
$var wire 16 < read_data [15:0] $end
$var wire 1 1 rd $end
$var wire 16 = address [15:0] $end
$var integer 32 > i [31:0] $end
$upscope $end
$scope module instruction_decode $end
$var wire 1 8 clk $end
$var wire 24 ? instruction [23:0] $end
$var wire 16 @ mem_data [15:0] $end
$var wire 16 A op1 [15:0] $end
$var wire 4 B reg_id1 [3:0] $end
$var wire 4 C wb_reg [3:0] $end
$var wire 1 ( wr_en_reg2 $end
$var wire 1 ) wr_en_reg1 $end
$var wire 1 ' wr_en_mem $end
$var wire 4 D reg_id2 [3:0] $end
$var wire 16 E reg_data2 [15:0] $end
$var wire 16 F reg_data1 [15:0] $end
$var wire 1 / rd_en_reg2 $end
$var wire 1 0 rd_en_reg1 $end
$var wire 1 1 rd_en_mem $end
$var wire 6 G opcode [5:0] $end
$var wire 16 H op2 [15:0] $end
$var wire 2 I mode [1:0] $end
$var wire 16 J mem_addr [15:0] $end
$var reg 16 K mem_addr_temp [15:0] $end
$var reg 1 1 rd_en_mem_temp $end
$var reg 1 0 rd_en_reg1_temp $end
$var reg 1 / rd_en_reg2_temp $end
$var reg 4 L reg_id1_temp [3:0] $end
$var reg 4 M reg_id2_temp [3:0] $end
$var reg 1 ' wr_en_mem_temp $end
$var reg 1 ) wr_en_reg1_temp $end
$var reg 1 ( wr_en_reg2_temp $end
$upscope $end
$scope module register $end
$var wire 1 8 clk $end
$var wire 1 0 rd1 $end
$var wire 1 / rd2 $end
$var wire 4 N reg_id1 [3:0] $end
$var wire 4 O reg_id2 [3:0] $end
$var wire 1 : reset $end
$var wire 1 ) wn1 $end
$var wire 1 ( wn2 $end
$var wire 16 P write_data1 [15:0] $end
$var wire 16 Q write_data2 [15:0] $end
$var wire 16 R read_data2 [15:0] $end
$var wire 16 S read_data1 [15:0] $end
$var integer 32 T i [31:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b10000 T
bx S
bx R
bz Q
bz P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
b10000 >
bx =
bx <
bz ;
x:
bx 9
08
bx 7
bx 6
bx 5
bx 4
bx 3
bx 2
x1
x0
x/
bx .
bx -
bx ,
bx +
bx *
x)
x(
x'
bz &
bz %
bz $
0#
1"
z!
$end
#10
0)
10
18
#20
08
#30
18
#40
08
#50
18
#60
08
#70
18
#80
08
#90
18
#100
b0 2
b0 G
b0 5
b0 I
b100000000000100 9
b100000000000100 ?
08
#110
b101 3
b101 H
b101 -
b101 E
b101 R
b1001 4
b1001 A
b1001 .
b1001 F
b1001 S
b0 +
b0 D
b0 M
b0 O
0(
1/
b100 ,
b100 B
b100 N
b100 *
b100 C
b100 L
18
#120
bx 3
bx H
b100 2
b100 G
b1 5
b1 I
b100010011000000000110 9
b100010011000000000110 ?
08
#130
b11100001000 3
b11100001000 H
b11100001000 6
b11100001000 <
b11100001000 @
b1000 4
b1000 A
b1000 .
b1000 F
b1000 S
b110 7
b110 =
b110 J
b110 K
0'
11
b11 ,
b11 B
b11 N
b11 *
b11 C
b11 L
18
#140
b101 3
b101 H
b11 2
b11 G
b0 5
b0 I
b11000110000000001000 9
b11000110000000001000 ?
08
#150
b1011 4
b1011 A
b1011 .
b1011 F
b1011 S
b110 ,
b110 B
b110 N
b110 *
b110 C
b110 L
18
#160
b110 3
b110 H
b100 2
b100 G
b10 5
b10 I
b100100011000000000110 9
b100100011000000000110 ?
08
#170
b1000 4
b1000 A
b1000 .
b1000 F
b1000 S
b11 ,
b11 B
b11 N
b11 *
b11 C
b11 L
18
#180
08
#190
18
#200
08
#210
18
#220
08
#230
18
#240
08
#250
18
#260
08
